#Декоратор

Този вид шаблон може да се използва за добавяне на функционалност към определен обект динамично, без това да засяга другите инстанции на същия клас. Това се постига чрез създаването на нов клас Декоратор, който „обвива“ класа. Това лесно може да се представи с примера, “опаковане на подарък, слагане на подаръка в кутия, опаковане на кутията“. Създава се поредица от обекти, която започва с декоратор обектите, отговорни за новите функционалности, и завършва с оригиналния обект.

Класовете и обектите, използвани при този модел са:

* Компонент – интерфейсът на обектите, към които могат да се добавят допълнителни функционалности или качества динамично;
* Конкретен компонент – обектът, към който ще се добавя нова функционалност;
* Декоратор – пази референция към компонент обекта и създава интерфейса, който съвпада с този на компонента;
* Конкретен декоратор – прибавя нови функционалности към обекта;


Особеностите на декоратора(методи, свойства и други) обикновено се определят от интерфейса, който е еднакъв за декораторите и за декорираните обекти. В посочения пример Компонент класът е наследен едновременно от Конктерния компонент и от подкласовете на Декоратор класа. Трябва да се отбележи, че декораторите и оригиналният обект имат общи свойства. При този шаблон за дизайн няколко декоратора могат да бъдат използвани върху една инстанция на даден обект, като всеки от тях добавя нова функционалност.

![Декоратор](http://www.oodesign.com/images/design_patterns/structural/decorator-design-pattern-implementation-uml-class-diagram.png)

#Композиция

Този шаблон се използва, когато трябва да се правят общи манипулации върху всички елементи на дървовидна структура от данни. Типичен пример за дървовидна стуктура е фаиловата система, в която ролята на клони играят папките, а листата са всички фаилове във тях. Папките могат да съдържат както други папки така и фаилове, като за всички тях имаме общи манипулации (копиране, листване и т.н.) Това е осъщетвено благодарение на добавянето на нов общ интерфейс(File System Resource Interface).

Класовете и обектите, използвани при този модел са:

* Компонент - абстракция за листата и клоните на нашата структура. Дефинира интерфейс, който трябва да бъде имплементиран от цялата композиция. 
* Листа - елементи, последните елементи от дъвовидната структура, които не се наследяват от други обекти и имплементират интерфейса.
* Клони - съдържат в себе си наследниците, като това не им пречи да имплементират всичко от Компонента. Композициите делегират имплементацията на интерфейса към техните наследници. Добавят се допълнителни методи за работа  с техните наследници.
* Клиент - работи във тази йерархия, като използва компонентния интерфейс.

Клиента може да осъществява всчка операция от компонентния интерфейс върху всеки елемент в дървовидната структура от данни, без значние дали е клон или листо.

![Композиция](http://www.oodesign.com/images/design_patterns/structural/composite-design-pattern-implementation-uml-class-diagram.png)

#Фасада

Този шаблон се използва за прикриването на комплексността на системата и дава на клиента лесен начин за използване. Прави се единствен клас, който съсржа в себе си всичко изискано от клиента, като функционалност. Този клас от своя страна манипулира остатъка от системата за да може тя да работи нормално. Използва се в огромни и трудни за разбиране системи. 

Класовете и обектите, използвани при този модел са:

* Фасада - клас който е достъпен за клиента и може чрез него да се манипулира всяка подсистема.
* Подсистеми - части от нашето приложение, който са скрити за клинта заради тяхната сложност.

![Фасада](http://www.dotnet-tricks.com/Content/images/designpatterns/facade.png)

